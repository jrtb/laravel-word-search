# Conversation Prompt

You are assisting with a Laravel Word Search application. This application allows users to create, solve, and share word search puzzles, as well as track their longest discovered words.

Please consider the following context when providing assistance:

1. This is a Laravel-based web application using:
   - PHP ^8.2
   - Laravel Framework ^11.31
   - Node.js with Vite ^5.0
   - Tailwind CSS ^3.4.13
   - AWS S3 (via league/flysystem-aws-s3-v3 ^3.29)
   - Swagger/OpenAPI (via darkaonline/l5-swagger ^8.6)

2. Laravel 11 Specific Architecture:
   - No HTTP/Console Kernel.php files - all middleware and exception handling is in bootstrap/app.php
   - Simplified application bootstrapping using fluent configuration
   - Middleware groups configured using ->withMiddleware() in bootstrap/app.php
   - Route registration using ->withRouting() in bootstrap/app.php
   - Service providers registered using ->withProviders() for specific functionality
   - Simplified directory structure with removal of traditional bootstrap files

3. Key Features:
   - Word search puzzle functionality
   - Pattern-based word searching
   - Frequency-based word analysis
   - Longest word tracking system:
     - Session-based player identification using PlayerIdentityService
     - Request fingerprinting for player recognition
     - Individual longest word records per player
     - Top 10 longest words leaderboard
     - Cross-session player identity maintenance

4. Database Structure:
   - Uses migrations for schema management
   - Key tables include:
     - longest_words: Tracks player word submissions
       - session_id: Current session identifier
       - player_id: Unique player identifier (generated via PlayerIdentityService)
       - word: The submitted word
       - timestamps: Created/updated tracking

5. Player Identity System:
   - PlayerIdentityService handles player identification
   - Uses request fingerprinting to recognize returning players
   - Maintains player identity across sessions
   - Supports both test and production environments
   - Follows Laravel's dependency injection patterns
   - Configurable fingerprinting strategy

6. Testing:
   - Feature tests for all API endpoints
   - Proper mocking of PlayerIdentityService
   - Session handling in tests
   - Database assertions
   - Test isolation and independence

7. The application uses Tailwind CSS for styling
8. Security and best practices should be maintained
9. Code should be clean, well-documented, and maintainable
10. The application is deployed in two environments:
    - Development: http://localhost:8000
    - Production: https://wordlists.fairladymedia.com
      - Hosted on AWS Lightsail
      - Uses Bitnami Laravel stack
      - Web server runs as 'daemon' user
      - Application root: /home/bitnami/stack/apache2/htdocs/laravel-word-search
      - Requires specific Bitnami-compatible file permissions

11. Security and Error Handling:
    - CSRF Protection:
      - All web routes protected by CSRF tokens
      - Token included in blade templates via meta tag
      - JavaScript requests include X-CSRF-TOKEN header
      - Enhanced error handling for token mismatches
    - Client-Side Error Handling:
      - Comprehensive error logging
      - User-friendly error messages
      - Loading states and indicators
      - Fallback content for failed requests
    - Server-Side Error Handling:
      - Detailed error responses
      - Proper status codes
      - Consistent error format
      - Environment-specific error detail levels

Before providing assistance:
1. Verify compatibility with Laravel 11's architecture and versions specified above
2. Review the README.md file to understand:
   - Application architecture
   - API endpoints and documentation
   - Installation and setup procedures
   - Current features and functionality
3. Consider existing test coverage and patterns in the test suite
4. Be aware of the environment context (development vs. production)

When suggesting changes or providing solutions:
- Ensure compatibility with Laravel 11's conventions and architecture
- Use Laravel 11's fluent configuration APIs where applicable
- Consider performance implications
- Maintain existing code style and patterns
- Include necessary tests when appropriate
- Consider user experience in frontend changes
- Ensure changes work in both development and production environments

After implementing changes:
1. Update relevant documentation:
   - README.md for new features or changes
   - API documentation (Swagger)
   - Postman collection and environments
2. Add or update tests:
   - Unit tests for new functionality
   - Feature tests for API endpoints
   - Update existing tests if behavior changes
3. Verify changes don't break existing functionality

For major changes:
- Provide a summary of all updates made
- List any new dependencies added
- Highlight any configuration changes needed
- Include any necessary migration steps
- Ensure changes align with Laravel 11's architectural patterns

When handling errors:
- Provide clear, user-friendly error messages
- Log detailed error information for debugging
- Maintain security by not exposing sensitive information
- Consider both development and production environments
- Follow Laravel 11's error handling patterns
- Implement proper loading states and fallbacks
